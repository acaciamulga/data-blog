---
title: Working with names in rgbif
author: John Waller
date: '2021-08-13'
slug: rgbif-names
categories:
  - GBIF
tags:
  - rgbif
lastmod: '2021-08-13T15:26:29+02:00'
draft: yes
keywords: []
description: ''
authors: ''
comment: no
toc: ''
autoCollapseToc: no
postMetaInFooter: no
hiddenFromHomePage: yes
contentCopyright: no
reward: no
mathjax: no
mathjaxEnableSingleDollar: no
mathjaxEnableAutoNumber: no
hideHeaderAndFooter: no
flowchartDiagrams:
  enable: no
  options: ''
sequenceDiagrams:
  enable: no
  options: ''
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>Matching names to the GBIF backbone is one of the most important steps in any GBIF workflow.</p>
<p>There are several functions within rgbif that deal with scientific names, so it can be difficult to know what function to use when trying to match names to the GBIF backbone.</p>
<p>There are several names</p>
<ul>
<li><code>name_backbone()</code></li>
<li><code>name_usage()</code></li>
<li><code>name_suggest()</code></li>
<li><code>name_lookup()</code></li>
</ul>
<p><strong>If you just want to match your names to the GBIF backbone</strong> (get taxonkeys), I would use <code>rgbif::name_backbone()</code>.</p>
<pre><code>library(rgbif)

name_backbone(name=&quot;Puma concolor (Linnaeus, 1771)&quot;)
</code></pre>
<p>Usually you are not trying to match just one name, so here is a more realistic example of a <code>data.frame</code> of names and some post-processing filtering.</p>
<pre class="r"><code>library(rgbif)
library(purrr)

names = c(
&quot;Cirsium arvense (L.) Scop.&quot;, # a plant
&quot;Calopteryx splendens (Harris, 1780)&quot;, # an insect
&quot;Puma concolor (Linnaeus, 1771)&quot;, # a big cat
&quot;Ceylonosticta alwisi (Priyadarshana &amp; Wijewardhane, 2016)&quot;, # newly discovered insect 
&quot;Puma concuolor (Linnaeus, 1771)&quot;, # a mis-spelled big cat
&quot;Fake species (John Waller 2021)&quot; # a fake species  
)

names %&gt;%
map(~ name_backbone(name=.x)) %&gt;% 
bind_rows()
</code></pre>
<p>Name matching is going to always work better if you have an author string. Since scientific names are not great identifiers, having an author string greatly increases the chances of getting an unambiguous match.</p>
<p>You might have noticed some funny names in the previous example, so you will probably want to do some filtering</p>
<!-- name_usage(name='Calopteryx splendens')$data %>% -->
<!-- glimpse() -->
<p>When starting to work with rgbif and GBIF it is sometimes hard to know where to start.</p>
<p>In this guide I will be going through.</p>
<p>In my opinion there are around 5 steps to any GBIF-realted research project.</p>
<ol style="list-style-type: decimal">
<li>match your names to the GBIF backbone</li>
<li>download your GBIF subset</li>
<li>clean your download</li>
<li>run your model</li>
<li>cite your download</li>
</ol>
<p>All of these steps can be done in rgbif.</p>
<!--more-->
<div id="match-names-to-the-gbif-backbone" class="section level3">
<h3>Match names to the GBIF backbone</h3>
<p>This is often the most difficult task when starting to work in GBIF.</p>
<p>If you are working with one well-known group, this task can be easier. By just looking up the species in the web portal.</p>
<p>If you have a longer list of names, then it usually makes sense to automate the name matching.</p>
<p>Name matching means that you will get back a GBIF taxonkey (an integer), which represents the taxon (species,genus,family â€¦ ) of the text you are looking for. If you are curious how the GBIF backbone is working, check this article.</p>
<pre class="r"><code>library(rgbif)

</code></pre>
<p>Setting up your r environment for working with GBIF.</p>
<pre class="r"><code>library(dplyr)
library(readr)
library(rgbif)
library(taxize)
library(CoordinateCleaner)

# 4 Odonata scientific names
name_list = 
c(
&quot;Cordulegaster charpentieri Kolenati, 1846&quot;,
&quot;Cordulegaster talaria Tennessen, 2004&quot;,
&quot;Calopteryx splendens Harris, 1780&quot;,
&quot;Epiophlebia laidlawi Tillyard, 1921&quot;
)

# match names to GBIF taxonkeys
gbif_taxon_keys = name_list %&gt;% 
taxize::get_gbifid_(method=&quot;backbone&quot;) %&gt;% # get the gbif taxonkey
bind_rows() %&gt;%
filter(matchtype == &quot;EXACT&quot; &amp; status == &quot;ACCEPTED&quot;) %&gt;%
filter(order == &quot;Odonata&quot;) %&gt;% # remove anything that might have matched to a non-dragonfly
pull(usagekey) # get the GBIF taxonkeys

user=&quot;jwaller&quot; # your GBIF user name
pwd=&quot;&quot; # your GBIF password 
email=&quot;jwaller@gbif.org&quot; # your email

gbif_download_key = occ_download(
type=&quot;and&quot;,
pred_in(&quot;taxonKey&quot;, gbif_taxon_keys),
pred(&quot;hasGeospatialIssue&quot;, FALSE),
pred(&quot;hasCoordinate&quot;, TRUE),
format = &quot;SIMPLE_CSV&quot;,
user=user,pwd=pwd,email=email
)

# &lt;&lt;gbif download&gt;&gt;
  # Username: jwaller
  # E-mail: jwaller@gbif.org
  # Format: SIMPLE_CSV
  # Download key: 0253330-200613084148143


## Wait 10-15 min
## Need to wait for download to finish to run next part

gbif_download_key = &quot;0253330-200613084148143&quot;
path_to_download = &quot;C:/Users/ftw712/Desktop/&quot;

# download the file to your machine
rgbif::occ_download_get(gbif_download_key, path = path_to_download, overwrite = FALSE)
# Sometimes easier to just get download from GBIF user profile
# https://www.gbif.org/user/download

# can do this &quot;manually&quot; just want script to run without stopping
zip_file = paste0(path_to_download,gbif_download_key,&quot;.zip&quot;)
extract_dir = paste0(path_to_download,gbif_download_key)
unzip(zip_file,exdir=extract_dir)

# read in download. Recommend data.table::fread() to avoid parsing errors sometimes that happen sometimes with other csv readers
gbif_download = data.table::fread(paste0(path_to_download,gbif_download_key,&quot;/&quot;,gbif_download_key,&quot;.csv&quot;)) %&gt;%
glimpse()

# Post processing GBIF download 
gbif_clean_data = gbif_download %&gt;%
setNames(tolower(names(.))) %&gt;% # set lowercase column names to work with CoordinateCleaner
filter(occurrencestatus  == &quot;PRESENT&quot;) %&gt;%
filter(!is.na(decimallongitude)) %&gt;% 
filter(!is.na(decimallatitude)) %&gt;% 
filter(!basisofrecord %in% c(&quot;FOSSIL_SPECIMEN&quot;,&quot;LIVING_SPECIMEN&quot;)) %&gt;%
filter(!establishmentmeans %in% c(&quot;MANAGED&quot;, &quot;INTRODUCED&quot;, &quot;INVASIVE&quot;, &quot;NATURALISED&quot;)) %&gt;%
filter(year &gt;= 1900) %&gt;% 
filter(coordinateprecision &gt; 0.01 | is.na(coordinateprecision)) %&gt;% 
filter(coordinateuncertaintyinmeters &lt; 10000 | is.na(coordinateuncertaintyinmeters)) %&gt;%
filter(!coordinateuncertaintyinmeters %in% c(301,3036,999,9999)) %&gt;% 
filter(!decimallatitude == 0 | !decimallongitude == 0) %&gt;%
cc_cen(buffer = 2000) %&gt;% # remove country centroids within 2km 
cc_cap(buffer = 2000) %&gt;% # remove capitals centroids within 2km
cc_inst(buffer = 2000) %&gt;% # remove zoo and herbaria within 2km 
cc_sea() %&gt;% # remove from ocean 
distinct(decimallongitude,decimallatitude,specieskey,datasetkey, .keep_all = TRUE) %&gt;% # this removes a lot of records! 
glimpse() # look at results of pipeline

# 168,593 # before cleaning
#  54,938 # after</code></pre>
</div>
